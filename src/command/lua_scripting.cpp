/*
 *Copyright (c) 2013-2014, yinqiwen <yinqiwen@gmail.com>
 *All rights reserved.
 *
 *Redistribution and use in source and binary forms, with or without
 *modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of Redis nor the names of its contributors may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 *THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 *BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 *THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "comms.hpp"
#include "lua_scripting.hpp"
#include "logger.hpp"
#include "util/rand.h"
#include "thread/thread_mutex.hpp"
#include <string.h>
#include <limits>
#include <math.h>

#define MAX_LUA_STR_SIZE 1024

namespace comms
{
    extern "C"
    {
        int (luaopen_cjson)(lua_State *L);
        int (luaopen_struct)(lua_State *L);
        int (luaopen_cmsgpack)(lua_State *L);
    }

    static ThreadMutex g_lua_mutex;

    /* Take a Redis reply in the Redis protocol format and convert it into a
     * Lua type. Thanks to this function, and the introduction of not connected
     * clients, it is trivial to implement the redis() lua function.
     *
     * Basically we take the arguments, execute the Redis command in the context
     * of a non connected client, then take the generated reply and convert it
     * into a suitable Lua type. With this trick the scripting feature does not
     * need the introduction of a full Redis internals API. Basically the script
     * is like a normal client that bypasses all the slow I/O paths.
     *
     * Note: in this function we do not do any sanity check as the reply is
     * generated by Redis directly. This allows us to go faster.
     * The reply string can be altered during the parsing as it is discarded
     * after the conversion is completed.
     *
     * Errors are returned as a table with a single 'err' field set to the
     * error string.
     */

    static void redisProtocolToLuaType(lua_State *lua, RedisReply& reply)
    {
        switch (reply.type)
        {
            case REDIS_REPLY_INTEGER:
            {
                lua_pushnumber(lua, (lua_Number) reply.integer);
                break;
            }
            case REDIS_REPLY_NIL:
            {
                lua_pushboolean(lua, 0);
                break;
            }
            case REDIS_REPLY_STRING:
            {
                lua_pushlstring(lua, reply.str.data(), reply.str.size());
                break;
            }
            case REDIS_REPLY_STATUS:
            {
                lua_newtable(lua);
                lua_pushstring(lua, "ok");
                lua_pushlstring(lua, reply.str.data(), reply.str.size());
                lua_settable(lua, -3);
                break;
            }
            case REDIS_REPLY_ERROR:
            {
                lua_newtable(lua);
                lua_pushstring(lua, "err");
                lua_pushlstring(lua, reply.str.data(), reply.str.size());
                lua_settable(lua, -3);
                break;
            }
            case REDIS_REPLY_ARRAY:
            {
                lua_newtable(lua);
                for (uint32 j = 0; j < reply.MemberSize(); j++)
                {
                    lua_pushnumber(lua, j + 1);
                    redisProtocolToLuaType(lua, reply.MemberAt(j));
                    lua_settable(lua, -3);
                }
                break;
            }
            default:
            {
                break;
            }
        }
    }

    /* Set an array of Redis String Objects as a Lua array (table) stored into a
     * global variable. */
    static void luaSetGlobalArray(lua_State *lua, const std::string& var, DataArray& elev)
    {
        uint32 j;

        lua_newtable(lua);
        for (j = 0; j < elev.size(); j++)
        {
            lua_pushlstring(lua, elev[j].Value(), elev[j].Len());
            lua_rawseti(lua, -2, j + 1);
        }
        lua_setglobal(lua, var.c_str());
    }

    /* This function installs metamethods in the global table _G that prevent
     * the creation of globals accidentally.
     *
     * It should be the last to be called in the scripting engine initialization
     * sequence, because it may interact with creation of globals. */
    static void scriptingEnableGlobalsProtection(lua_State *lua)
    {
        const char *s[32];
        std::string code;
        int j = 0;

        /* strict.lua from: http://metalua.luaforge.net/src/lib/strict.lua.html.
         * Modified to be adapted to Redis. */
        s[j++] = "local mt = {}\n";
        s[j++] = "setmetatable(_G, mt)\n";
        s[j++] = "mt.__newindex = function (t, n, v)\n";
        s[j++] = "  if debug.getinfo(2) then\n";
        s[j++] = "    local w = debug.getinfo(2, \"S\").what\n";
        s[j++] = "    if w ~= \"main\" and w ~= \"C\" then\n";
        s[j++] = "      error(\"Script attempted to create global variable '\"..tostring(n)..\"'\", 2)\n";
        s[j++] = "    end\n";
        s[j++] = "  end\n";
        s[j++] = "  rawset(t, n, v)\n";
        s[j++] = "end\n";
        s[j++] = "mt.__index = function (t, n)\n";
        s[j++] = "  if debug.getinfo(2) and debug.getinfo(2, \"S\").what ~= \"C\" then\n";
        s[j++] = "    error(\"Script attempted to access unexisting global variable '\"..tostring(n)..\"'\", 2)\n";
        s[j++] = "  end\n";
        s[j++] = "  return rawget(t, n)\n";
        s[j++] = "end\n";
        s[j++] = NULL;

        for (j = 0; s[j] != NULL; j++)
        {
            code.append(s[j]);
        }
        luaL_loadbuffer(lua, code.c_str(), code.size(), "@enable_strict_lua");
        lua_pcall(lua, 0, 0, 0);
    }
    static void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc)
    {
        lua_pushcfunction(lua, luafunc);
        lua_pushstring(lua, libname);
        lua_call(lua, 1, 0);
    }

    static void luaPushError(lua_State *lua, const char *error)
    {
        lua_Debug dbg;

        lua_newtable(lua);
        lua_pushstring(lua, "err");

        /* Attempt to figure out where this function was called, if possible */
        if (lua_getstack(lua, 1, &dbg) && lua_getinfo(lua, "nSl", &dbg))
        {
            char tmp[MAX_LUA_STR_SIZE];
            snprintf(tmp, MAX_LUA_STR_SIZE - 1, "%s: %d: %s", dbg.source, dbg.currentline, error);
            lua_pushstring(lua, tmp);
        }
        else
        {
            lua_pushstring(lua, error);
        }
        lua_settable(lua, -3);
    }

    static int luaReplyToRedisReply(lua_State *lua, RedisReply& reply)
    {
        int t = lua_type(lua, -1);
        switch (t)
        {
            case LUA_TSTRING:
            {
                reply.type = REDIS_REPLY_STRING;
                reply.str.append((char*) lua_tostring(lua, -1), lua_strlen(lua, -1));
                break;
            }
            case LUA_TBOOLEAN:
                if (lua_toboolean(lua, -1))
                {
                    reply.type = REDIS_REPLY_INTEGER;
                    reply.integer = 1;
                }
                else
                {
                    reply.type = REDIS_REPLY_NIL;
                }
                break;
            case LUA_TNUMBER:
                reply.type = REDIS_REPLY_INTEGER;
                reply.integer = (long long) lua_tonumber(lua, -1);
                break;
            case LUA_TTABLE:
                /* We need to check if it is an array, an error, or a status reply.
                 * Error are returned as a single element table with 'err' field.
                 * Status replies are returned as single element table with 'ok' field */
                lua_pushstring(lua, "err");
                lua_gettable(lua, -2);
                t = lua_type(lua, -1);
                if (t == LUA_TSTRING)
                {
                    std::string err = lua_tostring(lua, -1);
                    string_replace(err, "\r\n", " ");
                    reply.type = REDIS_REPLY_ERROR;
                    reply.str = err;
                    lua_pop(lua, 2);
                    return 0;
                }

                lua_pop(lua, 1);
                lua_pushstring(lua, "ok");
                lua_gettable(lua, -2);
                t = lua_type(lua, -1);
                if (t == LUA_TSTRING)
                {
                    std::string ok = lua_tostring(lua, -1);
                    string_replace(ok, "\r\n", " ");
                    reply.str = ok;
                    reply.type = REDIS_REPLY_STATUS;
                    lua_pop(lua, 1);
                }
                else
                {
                    //void *replylen = addDeferredMultiBulkLength(c);
                    int j = 1, mbulklen = 0;

                    lua_pop(lua, 1);
                    /* Discard the 'ok' field value we popped */
                    reply.type = REDIS_REPLY_ARRAY;
                    while (1)
                    {
                        lua_pushnumber(lua, j++);
                        lua_gettable(lua, -2);
                        t = lua_type(lua, -1);
                        if (t == LUA_TNIL)
                        {
                            lua_pop(lua, 1);
                            break;
                        }
                        RedisReply& r = reply.AddMember();
                        luaReplyToRedisReply(lua, r);
                        mbulklen++;
                    }
                }
                break;
            default:
            {
                reply.type = REDIS_REPLY_NIL;
                break;
            }

        }
        lua_pop(lua, 1);
        return 0;
    }

    int Comms::Eval(Context& ctx, RedisCommandFrame& cmd)
    {
        uint32 numkey = 0;
        if (!string_touint32(cmd.GetArguments()[1], numkey))
        {
            fill_error_reply(ctx.reply, "value is not an integer or out of range");
            return 0;
        }
        if (cmd.GetArguments().size() < numkey + 2)
        {
            fill_error_reply(ctx.reply, "Wrong number of arguments for Eval");
            return 0;
        }
        DataArray keys, args;
        for (uint32 i = 2; i < numkey + 2; i++)
        {
            keys.push_back(cmd.GetArguments()[i]);
        }
        for (uint32 i = numkey + 2; i < cmd.GetArguments().size(); i++)
        {
            args.push_back(cmd.GetArguments()[i]);
        }
        m_lua.Eval(ctx, cmd.GetArguments()[0], keys, args, false, ctx.reply);
        return 0;
    }

    int Comms::EvalSHA(Context& ctx, RedisCommandFrame& cmd)
    {
        uint32 numkey = 0;
        if (!string_touint32(cmd.GetArguments()[1], numkey))
        {
            fill_error_reply(ctx.reply, "value is not an integer or out of range");
            return 0;
        }
        if (cmd.GetArguments().size() < numkey + 2)
        {
            fill_error_reply(ctx.reply, "Wrong number of arguments for Eval");
            return 0;
        }
        DataArray keys, args;
        for (uint32 i = 2; i < numkey + 2; i++)
        {
            keys.push_back(cmd.GetArguments()[i]);
        }
        for (uint32 i = numkey + 2; i < cmd.GetArguments().size(); i++)
        {
            args.push_back(cmd.GetArguments()[i]);
        }
        m_lua.Eval(ctx, cmd.GetArguments()[0], keys, args, true, ctx.reply);
        if(ctx.data_change && !ctx.flags.no_wal)
        {
            std::string script;
            if(0 == GetScript(cmd.GetArguments()[0], script))
            {
                ctx.current_cmd->SetCommand("eval");
                ctx.current_cmd->GetMutableArguments()[0].assign(script);
            }
        }
        return 0;
    }

    int Comms::Script(Context& ctx, RedisCommandFrame& cmd)
    {
        const std::string& subcommand = cmd.GetArguments()[0];
        if (!strcasecmp(subcommand.c_str(), "EXISTS"))
        {
            std::vector<int64> intarray;
            for (uint32 i = 1; i < cmd.GetArguments().size(); i++)
            {
                bool exists = m_lua.Exists(cmd.GetArguments()[i]);
                intarray.push_back(exists ? 1 : 0);
            }
            fill_int_array_reply(ctx.reply, intarray);
            return 0;
        }
        else if (!strcasecmp(subcommand.c_str(), "FLUSH"))
        {
            if (cmd.GetArguments().size() != 1)
            {
                fill_error_reply(ctx.reply, "wrong number of arguments for SCRIPT FLUSH");
            }
            else
            {
                FlushScripts(ctx);
                fill_status_reply(ctx.reply, "OK");
            }
        }
        /*
         * NOTE: 'SCRIPT KILL' may need func's sha1 as argument because comms may run in multi threading mode,
         *       while more than ONE scripts may be running at the same time.
         *       Redis do NOT need the argument.
         */
        else if (!strcasecmp(subcommand.c_str(), "KILL"))
        {
            if (cmd.GetArguments().size() > 2)
            {
                fill_error_reply(ctx.reply, "wrong number of arguments for SCRIPT KILL");
            }
            else
            {
                if (cmd.GetArguments().size() == 2)
                {
                    m_lua.Kill(ctx, cmd.GetArguments()[1]);
                }
                else
                {
                    m_lua.Kill(ctx, "all");
                }
                fill_status_reply(ctx.reply, "OK");
            }
        }
        else if (!strcasecmp(subcommand.c_str(), "LOAD"))
        {
            if (cmd.GetArguments().size() != 2)
            {
                fill_error_reply(ctx.reply, "wrong number of arguments for SCRIPT LOAD");
            }
            else
            {
                std::string result;
                if (m_lua.Load(cmd.GetArguments()[1], result))
                {
                    fill_str_reply(ctx.reply, result);
                }
                else
                {
                    fill_error_reply(ctx.reply, result.c_str());
                }
            }
        }
        else
        {
            fill_error_reply(ctx.reply, "Syntax error, try SCRIPT (EXISTS | FLUSH | KILL | LOAD)");
        }
        return 0;
    }

    std::string LUAInterpreter::m_killing_func;

    LUAInterpreter::LUAInterpreter() :
            m_lua(NULL)
    {
        Init();
    }

    /* Define a lua function with the specified function name and body.
     * The function name musts be a 2 characters long string, since all the
     * functions we defined in the Lua context are in the form:
     *
     *   f_<hex sha1 sum>
     *
     * On success REDIS_OK is returned, and nothing is left on the Lua stack.
     * On error REDIS_ERR is returned and an appropriate error is set in the
     * client context. */
    int LUAInterpreter::CreateLuaFunction(const std::string& funcname, const std::string& body, std::string& err)
    {
        std::string funcdef = "function ";
        funcdef.append(funcname);
        funcdef.append("() ");
        funcdef.append(body);
        funcdef.append(" end");

        if (luaL_loadbuffer(m_lua, funcdef.c_str(), funcdef.size(), "@user_script"))
        {
            err.append("Error compiling script (new function): ").append(lua_tostring(m_lua, -1)).append("\n");
            lua_pop(m_lua, 1);
            return -1;
        }
        if (lua_pcall(m_lua, 0, 0, 0))
        {
            err.append("Error running script (new function): ").append(lua_tostring(m_lua, -1)).append("\n");
            lua_pop(m_lua, 1);
            return -1;
        }

        /* We also save a SHA1 -> Original script map in a dictionary
         * so that we can replicate / write in the AOF all the
         * EVALSHA commands as EVAL using the original script. */
        g_db->SaveScript(funcname, body);
        return 0;
    }

    int LUAInterpreter::LoadLibs()
    {
        luaLoadLib(m_lua, "", luaopen_base);
        luaLoadLib(m_lua, LUA_TABLIBNAME, luaopen_table);
        luaLoadLib(m_lua, LUA_STRLIBNAME, luaopen_string);
        luaLoadLib(m_lua, LUA_MATHLIBNAME, luaopen_math);
        luaLoadLib(m_lua, LUA_DBLIBNAME, luaopen_debug);

        luaLoadLib(m_lua, "cjson", luaopen_cjson);
        luaLoadLib(m_lua, "struct", luaopen_struct);
        luaLoadLib(m_lua, "cmsgpack", luaopen_cmsgpack);
        return 0;
    }

    int LUAInterpreter::RemoveUnsupportedFunctions()
    {
        lua_pushnil(m_lua);
        lua_setglobal(m_lua, "loadfile");
        return 0;
    }

    static ThreadLocal<Context*> g_local_ctx;

    int LUAInterpreter::CallComms(lua_State *lua, bool raise_error)
    {
        int j, argc = lua_gettop(lua);
        ArgumentArray cmdargs;

        /* Require at least one argument */
        if (argc == 0)
        {
            luaPushError(lua, "Please specify at least one argument for redis.call()");
            return 1;
        }

        /* Build the arguments vector */
        for (j = 0; j < argc; j++)
        {
            if (!lua_isstring(lua, j + 1))
                break;
            std::string arg;
            arg.append(lua_tostring(lua, j + 1), lua_strlen(lua, j + 1));
            cmdargs.push_back(arg);
        }

        /* Check if one of the arguments passed by the Lua script
         * is not a string or an integer (lua_isstring() return true for
         * integers as well). */
        if (j != argc)
        {
            luaPushError(lua, "Lua redis() command arguments must be strings or integers");
            return 1;
        }

        /* Setup our fake client for command execution */

        RedisCommandFrame cmd(cmdargs);
        lower_string(cmd.GetMutableCommand());
        Comms::RedisCommandHandlerSetting* setting = g_db->FindRedisCommandHandlerSetting(cmd);
        /* Command lookup */
        if (NULL == setting)
        {
            luaPushError(lua, "Unknown Redis command called from Lua script");
            return -1;
        }

        /* There are commands that are not allowed inside scripts. */
        if (setting->flags & COMMS_CMD_NOSCRIPT)
        {
            luaPushError(lua, "This Redis command is not allowed from scripts");
            return -1;
        }

        Context* ctx = g_local_ctx.GetValue();
        RedisReply& reply = ctx->reply;
        reply.Clear();
        g_db->DoCall(*ctx, *setting, cmd);
        if (raise_error && reply.type != REDIS_REPLY_ERROR)
        {
            raise_error = 0;
        }
        redisProtocolToLuaType(g_db->m_lua.m_lua, reply);

        if (raise_error)
        {
            /* If we are here we should have an error in the stack, in the
             * form of a table with an "err" field. Extract the string to
             * return the plain error. */
            lua_pushstring(lua, "err");
            lua_gettable(lua, -2);
            return lua_error(lua);
        }
        return 1;
    }

    int LUAInterpreter::PCall(lua_State *lua)
    {
        return CallComms(lua, true);
    }

    int LUAInterpreter::Call(lua_State *lua)
    {
        return CallComms(lua, false);
    }

    int LUAInterpreter::Log(lua_State *lua)
    {
        int j, argc = lua_gettop(lua);
        int level;
        std::string log;
        if (argc < 2)
        {
            luaPushError(lua, "redis.log() requires two arguments or more.");
            return 1;
        }
        else if (!lua_isnumber(lua, -argc))
        {
            luaPushError(lua, "First argument must be a number (log level).");
            return 1;
        }
        level = (int) lua_tonumber(lua, -argc);
        if (level < FATAL_LOG_LEVEL || level > TRACE_LOG_LEVEL)
        {
            luaPushError(lua, "Invalid debug level.");
            return 1;
        }

        /* Glue together all the arguments */
        for (j = 1; j < argc; j++)
        {
            size_t len;
            char *s;

            s = (char*) lua_tolstring(lua, (-argc) + j, &len);
            if (s)
            {
                if (j != 1)
                {
                    log.append(" ");
                }
                log.append(s, len);
            }
        }
        LOG_WITH_LEVEL((LogLevel )level, "%s", log.c_str());
        return 0;
    }

    int LUAInterpreter::SHA1Hex(lua_State *lua)
    {
        int argc = lua_gettop(lua);
        size_t len;
        char *s;

        if (argc != 1)
        {
            luaPushError(lua, "wrong number of arguments");
            return 1;
        }

        s = (char*) lua_tolstring(lua, 1, &len);
        std::string digest = sha1_sum_data(s, len);
        lua_pushstring(lua, digest.c_str());
        return 1;
    }

    int LUAInterpreter::ReturnSingleFieldTable(lua_State *lua, const std::string& field)
    {
        if (lua_gettop(lua) != 1 || lua_type(lua, -1) != LUA_TSTRING)
        {
            luaPushError(lua, "wrong number or type of arguments");
            return 1;
        }

        lua_newtable(lua);
        lua_pushstring(lua, field.c_str());
        lua_pushvalue(lua, -3);
        lua_settable(lua, -3);
        return 1;
    }

    int LUAInterpreter::ErrorReplyCommand(lua_State *lua)
    {
        return ReturnSingleFieldTable(lua, "err");
    }
    int LUAInterpreter::StatusReplyCommand(lua_State *lua)
    {
        return ReturnSingleFieldTable(lua, "ok");
    }
    int LUAInterpreter::MathRandom(lua_State *L)
    {
        /* the `%' avoids the (rare) case of r==1, and is needed also because on
         some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
        lua_Number r = (lua_Number) (redisLrand48() % REDIS_LRAND48_MAX) / (lua_Number) REDIS_LRAND48_MAX;
        switch (lua_gettop(L))
        { /* check number of arguments */
            case 0:
            { /* no arguments */
                lua_pushnumber(L, r); /* Number between 0 and 1 */
                break;
            }
            case 1:
            { /* only upper limit */
                int u = luaL_checkint(L, 1);
                luaL_argcheck(L, 1 <= u, 1, "interval is empty");
                lua_pushnumber(L, floor(r * u) + 1); /* int between 1 and `u' */
                break;
            }
            case 2:
            { /* lower and upper limits */
                int l = luaL_checkint(L, 1);
                int u = luaL_checkint(L, 2);
                luaL_argcheck(L, l <= u, 2, "interval is empty");
                lua_pushnumber(L, floor(r * (u - l + 1)) + l); /* int between `l' and `u' */
                break;
            }
            default:
                return luaL_error(L, "wrong number of arguments");
        }
        return 1;
    }
    int LUAInterpreter::MathRandomSeed(lua_State *lua)
    {
        redisSrand48(luaL_checkint(lua, 1));
        return 0;
    }

    void LUAInterpreter::MaskCountHook(lua_State *lua, lua_Debug *ar)
    {
        COMMS_NOTUSED(ar);
        COMMS_NOTUSED(lua);
        Context& ctx = *(g_local_ctx.GetValue());
        uint64 elapsed = get_current_epoch_millis() - ctx.GetLua().lua_time_start;
        if (elapsed >= (uint64) g_db->GetConfig().lua_time_limit && !ctx.GetLua().lua_timeout)
        {
            WARN_LOG(
                    "Lua slow script detected: %s still in execution after %llu milliseconds. You can try killing the script using the SCRIPT KILL command.",
                    ctx.GetLua().lua_executing_func, elapsed);
            ctx.GetLua().lua_timeout = true;
        }
        if (ctx.GetLua().lua_timeout && NULL != ctx.client)
        {
            ctx.client->GetService().Continue();
        }
        if (ctx.GetLua().lua_kill)
        {
            WARN_LOG("Lua script killed by user with SCRIPT KILL.");
            lua_pushstring(lua, "Script killed by user with SCRIPT KILL...");
            lua_error(lua);
        }
    }

    int LUAInterpreter::Init()
    {
        m_lua = lua_open();

        LoadLibs();
        RemoveUnsupportedFunctions();

        /* Register the redis commands table and fields */
        lua_newtable(m_lua);

        /* redis.call */
        lua_pushstring(m_lua, "call");
        lua_pushcfunction(m_lua, LUAInterpreter::Call);
        lua_settable(m_lua, -3);

        /* redis.pcall */
        lua_pushstring(m_lua, "pcall");
        lua_pushcfunction(m_lua, LUAInterpreter::PCall);
        lua_settable(m_lua, -3);

        /* redis.log and log levels. */
        lua_pushstring(m_lua, "log");
        lua_pushcfunction(m_lua, LUAInterpreter::Log);
        lua_settable(m_lua, -3);

        lua_pushstring(m_lua, "LOG_DEBUG");
        lua_pushnumber(m_lua, DEBUG_LOG_LEVEL);
        lua_settable(m_lua, -3);

        lua_pushstring(m_lua, "LOG_VERBOSE");
        lua_pushnumber(m_lua, TRACE_LOG_LEVEL);
        lua_settable(m_lua, -3);

        lua_pushstring(m_lua, "LOG_NOTICE");
        lua_pushnumber(m_lua, INFO_LOG_LEVEL);
        lua_settable(m_lua, -3);

        lua_pushstring(m_lua, "LOG_WARNING");
        lua_pushnumber(m_lua, WARN_LOG_LEVEL);
        lua_settable(m_lua, -3);

        /* redis.sha1hex */
        lua_pushstring(m_lua, "sha1hex");
        lua_pushcfunction(m_lua, LUAInterpreter::SHA1Hex);
        lua_settable(m_lua, -3);

        /* redis.error_reply and redis.status_reply */
        lua_pushstring(m_lua, "error_reply");
        lua_pushcfunction(m_lua, LUAInterpreter::ErrorReplyCommand);
        lua_settable(m_lua, -3);
        lua_pushstring(m_lua, "status_reply");
        lua_pushcfunction(m_lua, LUAInterpreter::StatusReplyCommand);
        lua_settable(m_lua, -3);

        /* Finally set the table as 'redis' global var. */
        lua_setglobal(m_lua, "redis");
        lua_getglobal(m_lua, "redis");
        lua_setglobal(m_lua, "comms");

        /* Replace math.random and math.randomseed with our implementations. */
        lua_getglobal(m_lua, LUA_MATHLIBNAME);
        if (lua_isnil(m_lua, -1))
        {
            ERROR_LOG("Failed to load lib math");
        }
        lua_pushstring(m_lua, "random");
        lua_pushcfunction(m_lua, LUAInterpreter::MathRandom);
        lua_settable(m_lua, -3);

        lua_pushstring(m_lua, "randomseed");
        lua_pushcfunction(m_lua, LUAInterpreter::MathRandomSeed);
        lua_settable(m_lua, -3);

        lua_setglobal(m_lua, "math");

        /* Add a helper function we use for pcall error reporting.
         * Note that when the error is in the C function we want to report the
         * information about the caller, that's what makes sense from the point
         * of view of the user debugging a script. */
        {
            const char *errh_func = "function __redis__err__handler(err)\n"
                    "  local i = debug.getinfo(2,'nSl')\n"
                    "  if i and i.what == 'C' then\n"
                    "    i = debug.getinfo(3,'nSl')\n"
                    "  end\n"
                    "  if i then\n"
                    "    return i.source .. ':' .. i.currentline .. ': ' .. err\n"
                    "  else\n"
                    "    return err\n"
                    "  end\n"
                    "end\n";
            luaL_loadbuffer(m_lua, errh_func, strlen(errh_func), "@err_handler_def");
            lua_pcall(m_lua, 0, 0, 0);
        }

        scriptingEnableGlobalsProtection(m_lua);
        return 0;
    }

    int LUAInterpreter::Eval(Context& ctx, const std::string& func, DataArray& keys, DataArray& args, bool isSHA1Func,
            RedisReply& reply)
    {
        DEBUG_LOG("Exec script:%s", func.c_str());
        g_local_ctx.SetValue(&ctx);
        redisSrand48(0);
        std::string err;
        std::string funcname = "f_";
        const std::string* funptr = &func;
        if (isSHA1Func)
        {
            if (func.size() != 40)
            {
                reply.type = REDIS_REPLY_ERROR;
                reply.str = "NOSCRIPT No matching script. Please use EVAL.";
                return -1;
            }
            funcname.append(func);
        }
        else
        {
            std::string sha = sha1_sum(func);
            g_db->SaveScript(sha, func);
            funcname.append(sha);
        }
        LockGuard<ThreadMutex> guard(g_lua_mutex);
        /* Push the pcall error handler function on the stack. */
        lua_getglobal(m_lua, "__redis__err__handler");

        lua_getglobal(m_lua, funcname.c_str());
        if (lua_isnil(m_lua, -1))
        {
            lua_pop(m_lua, 1);
            /* remove the nil from the stack */
            /* Function not defined... let's define it if we have the
             * body of the function. If this is an EVALSHA call we can just
             * return an error. */
            std::string cachedfunc;
            if (isSHA1Func)
            {
                if (g_db->GetScript(funcname, cachedfunc) != 0)
                {
                    lua_pop(m_lua, 1);
                    /* remove the error handler from the stack. */
                    reply.type = REDIS_REPLY_ERROR;
                    reply.str = "NOSCRIPT No matching script. Please use EVAL.";
                    return -1;
                }
                funptr = &cachedfunc;
            }
            if (CreateLuaFunction(funcname, *funptr, err))
            {
                reply.type = REDIS_REPLY_ERROR;
                reply.str = err;
                lua_pop(m_lua, 1);
                return -1;
            }
            lua_getglobal(m_lua, funcname.c_str());
        }

        /* Populate the argv and keys table accordingly to the arguments that
         * EVAL received. */
        luaSetGlobalArray(m_lua, "KEYS", keys);
        luaSetGlobalArray(m_lua, "ARGV", args);

        bool delhook = false;
        if (g_db->GetConfig().lua_time_limit > 0)
        {
            lua_sethook(m_lua, MaskCountHook, LUA_MASKCOUNT, 100000);
            delhook = true;
        }
        ctx.GetLua().lua_time_start = get_current_epoch_millis();
        ctx.GetLua().lua_executing_func = funcname.c_str() + 2;
        ctx.GetLua().lua_kill = false;

        int errid = lua_pcall(m_lua, 0, 1, -2);
        ctx.GetLua().lua_executing_func = NULL;
        if (delhook)
        {
            lua_sethook(m_lua, MaskCountHook, 0, 0); /* Disable hook */
        }
        if (ctx.GetLua().lua_timeout)
        {
            ctx.GetLua().lua_timeout = false;
        }
        lua_gc(m_lua, LUA_GCSTEP, 1);

        if (errid)
        {
            reply.type = REDIS_REPLY_ERROR;
            char tmp[1024];
            snprintf(tmp, 1023, "Error running script (call to %s): %s", funcname.c_str(), lua_tostring(m_lua, -1));
            reply.str = tmp;
            lua_pop(m_lua, 2);
            /*  Consume the Lua reply and remove error handler. */
        }
        else
        {
            /* On success convert the Lua return value into Redis reply */
            reply.Clear();
            luaReplyToRedisReply(m_lua, reply);
            lua_pop(m_lua, 1); /* Remove the error handler. */
        }
        return 0;
    }

    bool LUAInterpreter::Exists(const std::string& sha)
    {
        std::string funcname = "f_";
        funcname.append(sha);
        std::string funcbody;
        return g_db->GetScript(funcname, funcbody) == 0;
    }

    int LUAInterpreter::Load(const std::string& func, std::string& ret)
    {
        std::string funcname = "f_";
        ret.clear();
        ret = sha1_sum(func);
        funcname.append(ret);
        return CreateLuaFunction(funcname, func, ret) == 0;
    }

    void LUAInterpreter::Reset()
    {
        LockGuard<ThreadMutex> guard(g_lua_mutex);
        lua_close(m_lua);
        Init();
    }

    int LUAInterpreter::Kill(Context& ctx, const std::string& funcname)
    {
        m_killing_func = funcname;
        if (ctx.client != NULL)
        {
            ctx.client->GetService().FireUserEvent(SCRIPT_KILL_EVENT);
        }
        return 0;
    }
    void LUAInterpreter::ScriptEventCallback(ChannelService* serv, uint32 ev, void* data)
    {
        Context* ctx = g_local_ctx.GetValue();
        if (NULL == ctx)
        {
            //no connection
            return;
        }
        switch (ev)
        {
            case SCRIPT_KILL_EVENT:
            {
                if (ctx->GetLua().lua_executing_func != NULL)
                {
                    if (!strcasecmp(m_killing_func.c_str(), "all")
                            || !strcasecmp(m_killing_func.c_str(), ctx->GetLua().lua_executing_func))
                    {
                        ctx->GetLua().lua_kill = true;
                    }
                }
                break;
            }
            default:
            {
                break;
            }
        }
    }

    LUAInterpreter::~LUAInterpreter()
    {
        lua_close(m_lua);
    }

    int Comms::GetScript(const std::string& funcname, std::string& funcbody)
    {
        LockGuard<SpinMutexLock> guard(m_scripts_lock);
        ScriptTable::iterator it = m_lua_scripts.find(funcname);
        if (it == m_lua_scripts.end())
        {
            return -1;
        }
        funcbody = it->second;
        return 0;
    }
    int Comms::SaveScript(const std::string& funcname, const std::string& funcbody)
    {
        LockGuard<SpinMutexLock> guard(m_scripts_lock);
        m_lua_scripts[funcname] = funcbody;
        return -1;
    }

    int Comms::FlushScripts(Context& ctx)
    {
        LockGuard<SpinMutexLock> guard(m_scripts_lock);
        m_lua_scripts.clear();
        m_lua.Reset();
        return 0;
    }
}

